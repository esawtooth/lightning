{% extends "base.html" %}

{% block title %}My Context Hub - Vextir{% endblock %}
{% block page_title %}My Context Hub{% endblock %}

{% block extra_head %}
<!-- Markdown rendering library -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<!-- jsTree for file tree component -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default/style.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/jstree.min.js"></script>
<style>
    /* Tree view styles */
    .tree-node {
        padding: 4px 8px;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .tree-node:hover {
        background-color: #f3f4f6;
        border-radius: 4px;
    }
    
    .tree-node.selected {
        background-color: #e0e7ff;
        border-radius: 4px;
    }
    
    .tree-children {
        margin-left: 0; /* Remove margin since we're using paddingLeft on nodes */
        border-left: 1px solid #e5e7eb;
        margin-left: 16px;
        padding-left: 0;
    }
    
    .tree-icon {
        width: 16px;
        text-align: center;
        flex-shrink: 0;
    }
    
    .tree-label {
        flex-grow: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    
    .file-preview {
        height: 100%;
        display: flex;
        flex-direction: column;
    }
    
    .editor-container {
        flex-grow: 1;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        overflow: hidden;
    }
    
    #editor {
        width: 100%;
        height: 100%;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        padding: 16px;
        resize: none;
        border: none;
        outline: none;
    }
    
    .split-view {
        display: grid;
        grid-template-columns: 300px 1fr;
        gap: 20px;
        height: calc(100vh - 280px);
    }
    
    .file-browser {
        background: white;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .browser-header {
        padding: 16px;
        border-bottom: 1px solid #e5e7eb;
        background-color: #f9fafb;
    }
    
    .browser-content {
        flex-grow: 1;
        overflow-y: auto;
        padding: 16px;
    }
    
    .content-panel {
        background: white;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .toolbar {
        display: flex;
        gap: 8px;
        padding: 12px 16px;
        border-bottom: 1px solid #e5e7eb;
        background-color: #f9fafb;
        align-items: center;
    }
    
    .toolbar button {
        padding: 6px 12px;
        font-size: 14px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        background: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.2s;
    }
    
    .toolbar button:hover {
        background-color: #f3f4f6;
        border-color: #9ca3af;
    }
    
    .toolbar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .context-menu {
        position: absolute;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        padding: 4px;
        z-index: 1000;
        min-width: 160px;
    }
    
    .context-menu-item {
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
    }
    
    .context-menu-item:hover {
        background-color: #f3f4f6;
    }
    
    .context-menu-divider {
        height: 1px;
        background-color: #e5e7eb;
        margin: 4px 0;
    }
    
    .status-bar {
        padding: 8px 16px;
        background-color: #f9fafb;
        border-top: 1px solid #e5e7eb;
        font-size: 12px;
        color: #6b7280;
        display: flex;
        justify-content: space-between;
    }
    
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #9ca3af;
        text-align: center;
        padding: 32px;
    }
    
    .empty-state i {
        font-size: 48px;
        margin-bottom: 16px;
        color: #d1d5db;
    }
    
    /* Timeline specific styles */
    .timeline-mode .tree-node {
        opacity: 0.8;
        pointer-events: none;
    }
    
    .timeline-mode .tree-node.timeline-selected {
        opacity: 1;
        pointer-events: auto;
        background-color: #fef3c7;
        border-left: 3px solid #f59e0b;
    }
    
    .timeline-flag {
        position: absolute;
        top: 0;
        width: 2px;
        height: 100%;
        cursor: pointer;
        transition: width 0.2s;
    }
    
    .timeline-flag:hover {
        width: 4px;
    }
    
    .timeline-flag.minor {
        background-color: #10b981;
    }
    
    .timeline-flag.moderate {
        background-color: #f59e0b;
    }
    
    .timeline-flag.major {
        background-color: #ef4444;
    }
    
    .timeline-flag-tooltip {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #1f2937;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s;
    }
    
    .timeline-flag:hover .timeline-flag-tooltip {
        opacity: 1;
    }
    
    .heatmap-segment {
        position: absolute;
        top: 0;
        height: 100%;
        transition: opacity 0.2s;
    }
    
    .heatmap-low {
        background-color: #f3f4f6;
    }
    
    .heatmap-medium {
        background-color: #fef3c7;
    }
    
    .heatmap-high {
        background-color: #dcfce7;
    }
    
    #timeline-scrubber {
        transition: left 0.1s ease-out;
    }
    
    #timeline-scrubber.dragging {
        transition: none;
        cursor: grabbing;
    }
    
    .document-diff {
        border-left: 4px solid #3b82f6;
        background-color: #eff6ff;
        padding: 8px 12px;
        margin: 4px 0;
        border-radius: 0 4px 4px 0;
    }
    
    .diff-added {
        background-color: #dcfce7;
        border-left-color: #10b981;
    }
    
    .diff-modified {
        background-color: #fef3c7;
        border-left-color: #f59e0b;
    }
    
    .diff-deleted {
        background-color: #fee2e2;
        border-left-color: #ef4444;
    }
    
    /* Markdown preview styles */
    .markdown-preview {
        padding: 20px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.6;
        color: #333;
        background: white;
        overflow-y: auto;
        height: 100%;
    }
    
    .markdown-preview h1 {
        font-size: 2em;
        margin: 0.67em 0;
        font-weight: 600;
        padding-bottom: 0.3em;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .markdown-preview h2 {
        font-size: 1.5em;
        margin: 0.75em 0;
        font-weight: 600;
        padding-bottom: 0.3em;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .markdown-preview h3 {
        font-size: 1.25em;
        margin: 1em 0;
        font-weight: 600;
    }
    
    .markdown-preview h4 {
        font-size: 1em;
        margin: 1.33em 0;
        font-weight: 600;
    }
    
    .markdown-preview h5 {
        font-size: 0.875em;
        margin: 1.67em 0;
        font-weight: 600;
    }
    
    .markdown-preview h6 {
        font-size: 0.85em;
        margin: 2.33em 0;
        font-weight: 600;
        color: #6b7280;
    }
    
    .markdown-preview p {
        margin: 1em 0;
    }
    
    .markdown-preview code {
        background-color: #f3f4f6;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.875em;
    }
    
    .markdown-preview pre {
        background-color: #f3f4f6;
        padding: 16px;
        border-radius: 6px;
        overflow-x: auto;
        margin: 1em 0;
    }
    
    .markdown-preview pre code {
        background-color: transparent;
        padding: 0;
        font-size: 0.875em;
    }
    
    .markdown-preview blockquote {
        border-left: 4px solid #e5e7eb;
        padding-left: 16px;
        margin: 1em 0;
        color: #6b7280;
    }
    
    .markdown-preview ul, .markdown-preview ol {
        margin: 1em 0;
        padding-left: 2em;
    }
    
    .markdown-preview li {
        margin: 0.25em 0;
    }
    
    .markdown-preview a {
        color: #3b82f6;
        text-decoration: none;
    }
    
    .markdown-preview a:hover {
        text-decoration: underline;
    }
    
    .markdown-preview img {
        max-width: 100%;
        height: auto;
        margin: 1em 0;
    }
    
    .markdown-preview table {
        border-collapse: collapse;
        width: 100%;
        margin: 1em 0;
    }
    
    .markdown-preview th, .markdown-preview td {
        border: 1px solid #e5e7eb;
        padding: 8px 12px;
        text-align: left;
    }
    
    .markdown-preview th {
        background-color: #f9fafb;
        font-weight: 600;
    }
    
    .markdown-preview hr {
        border: none;
        border-top: 1px solid #e5e7eb;
        margin: 2em 0;
    }
    
    /* Split view for markdown */
    .split-editor {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0;
        height: 100%;
    }
    
    .split-editor .editor-container {
        border-right: 1px solid #e5e7eb;
    }
    
    .split-editor .markdown-preview {
        border-left: 1px solid #e5e7eb;
    }
    
    /* Markdown toolbar */
    .markdown-toolbar {
        display: flex;
        gap: 8px;
        padding: 8px;
        background-color: #f9fafb;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .markdown-toolbar button {
        padding: 4px 8px;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        color: #374151;
        transition: all 0.2s;
    }
    
    .markdown-toolbar button:hover {
        background-color: #f3f4f6;
        border-color: #d1d5db;
    }
    
    .markdown-toolbar button.active {
        background-color: #3b82f6;
        color: white;
        border-color: #3b82f6;
    }
</style>
{% endblock %}

{% block content %}
<!-- Context Hub Status Bar -->
<div class="mb-6">
    <div class="bg-white rounded-lg shadow p-4">
        <div class="flex items-center justify-between">
            <div class="flex items-center gap-4">
                <h3 class="text-lg font-medium text-gray-900">Context Hub</h3>
                <div id="context-status" class="px-3 py-1 text-sm rounded-full bg-gray-100 text-gray-600">
                    <i class="fas fa-spinner fa-spin mr-1"></i>
                    Loading...
                </div>
            </div>
            <div class="flex items-center gap-2">
                <button id="init-context-btn" onclick="initializeContext()" class="hidden bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">
                    <i class="fas fa-database mr-2"></i>
                    Initialize Context Hub
                </button>
                <button id="timeline-toggle" onclick="toggleTimelineMode()" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition-colors">
                    <i class="fas fa-history mr-2"></i>
                    <span id="timeline-toggle-text">Timeline</span>
                </button>
                <button onclick="showSearchModal()" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">
                    <i class="fas fa-search mr-2"></i>
                    Search
                </button>
                <button onclick="refreshAll()" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">
                    <i class="fas fa-sync-alt mr-2"></i>
                    Refresh
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Timeline Mode Banner -->
<div id="timeline-banner" class="hidden mb-6">
    <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
        <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
                <i class="fas fa-history text-purple-600 text-lg"></i>
                <div>
                    <h4 class="font-medium text-purple-900">Timeline Mode - Read Only</h4>
                    <p class="text-sm text-purple-700">Viewing historical state at <span id="timeline-current-time">current time</span></p>
                </div>
            </div>
            <div class="flex items-center gap-2">
                <button id="restore-btn" onclick="showRestoreModal()" class="hidden bg-purple-600 text-white px-3 py-1 text-sm rounded hover:bg-purple-700">
                    <i class="fas fa-undo mr-1"></i>
                    Restore This Version
                </button>
                <button onclick="exitTimelineMode()" class="text-purple-600 hover:text-purple-800">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Timeline Scrubber -->
<div id="timeline-container" class="hidden mb-6">
    <div class="bg-white rounded-lg shadow p-4">
        <div class="mb-4 flex items-center justify-between">
            <h4 class="font-medium text-gray-900">Document History Timeline</h4>
            <div class="flex items-center gap-4">
                <span class="text-sm text-gray-600">Activity:</span>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-green-400 rounded-full"></div>
                    <span class="text-xs text-gray-500">High</span>
                    <div class="w-3 h-3 bg-yellow-400 rounded-full"></div>
                    <span class="text-xs text-gray-500">Medium</span>
                    <div class="w-3 h-3 bg-gray-300 rounded-full"></div>
                    <span class="text-xs text-gray-500">Low</span>
                </div>
            </div>
        </div>
        
        <!-- Timeline Track -->
        <div class="relative">
            <!-- Activity heatmap background -->
            <div id="timeline-heatmap" class="absolute inset-0 h-8 rounded-lg overflow-hidden">
                <!-- Heatmap segments will be inserted here -->
            </div>
            
            <!-- Change indicators -->
            <div id="timeline-flags" class="absolute inset-0 h-8">
                <!-- Change flags will be inserted here -->
            </div>
            
            <!-- Main timeline track -->
            <div id="timeline-track" class="relative h-8 bg-gray-200 rounded-lg cursor-pointer">
                <!-- Scrubber handle -->
                <div id="timeline-scrubber" class="absolute top-0 w-4 h-8 bg-purple-600 rounded shadow-lg cursor-grab transform -translate-x-2" style="left: 100%;">
                    <div class="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-gray-900 text-white text-xs px-2 py-1 rounded whitespace-nowrap" id="scrubber-tooltip">
                        Current
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Timeline controls -->
        <div class="mt-4 flex items-center justify-between">
            <div class="flex items-center gap-4">
                <span id="timeline-start" class="text-sm text-gray-600">Loading...</span>
                <button onclick="playTimeline()" class="bg-green-600 text-white px-3 py-1 text-sm rounded hover:bg-green-700">
                    <i class="fas fa-play mr-1"></i>
                    Play
                </button>
                <button onclick="pauseTimeline()" class="bg-gray-600 text-white px-3 py-1 text-sm rounded hover:bg-gray-700">
                    <i class="fas fa-pause mr-1"></i>
                    Pause
                </button>
            </div>
            <span id="timeline-end" class="text-sm text-gray-600">Loading...</span>
        </div>
    </div>
</div>

<!-- Main Split View -->
<div class="split-view">
    <!-- File Browser Panel -->
    <div class="file-browser">
        <div class="browser-header">
            <div class="flex items-center justify-between mb-2">
                <h4 class="font-medium text-gray-900">Files & Folders</h4>
                <div class="flex gap-2">
                    <button onclick="createNewFolder()" title="New Folder" class="p-1 hover:bg-gray-200 rounded">
                        <i class="fas fa-folder-plus text-sm"></i>
                    </button>
                    <button onclick="createNewFile()" title="New File" class="p-1 hover:bg-gray-200 rounded">
                        <i class="fas fa-file-alt text-sm"></i>
                    </button>
                    <button onclick="uploadFile()" title="Upload File" class="p-1 hover:bg-gray-200 rounded">
                        <i class="fas fa-upload text-sm"></i>
                    </button>
                </div>
            </div>
            <div class="text-xs text-gray-500">
                <span id="folder-count">0</span> folders, <span id="doc-count">0</span> documents
            </div>
        </div>
        <div class="browser-content">
            <div id="file-tree-container">
                <div id="file-tree">
                    <!-- Tree structure will be rendered here -->
                </div>
            </div>
            <div id="no-context" class="empty-state" style="display: none;">
                <i class="fas fa-folder-open"></i>
                <p class="text-gray-600 font-medium">No context hub initialized</p>
                <p class="text-sm mt-2">Click "Initialize Context Hub" to get started</p>
            </div>
        </div>
    </div>
    
    <!-- Content Panel -->
    <div class="content-panel">
        <div class="toolbar">
            <button id="save-btn" onclick="saveDocument()" disabled>
                <i class="fas fa-save"></i>
                Save
            </button>
            <button id="rename-btn" onclick="renameSelected()" disabled>
                <i class="fas fa-edit"></i>
                Rename
            </button>
            <button id="download-btn" onclick="downloadSelected()" disabled>
                <i class="fas fa-download"></i>
                Download
            </button>
            <button id="delete-btn" onclick="deleteSelected()" disabled>
                <i class="fas fa-trash"></i>
                Delete
            </button>
            <div class="flex-grow"></div>
            <button id="guide-btn" onclick="editGuideFile()" title="Edit Guide File">
                <i class="fas fa-book"></i>
                Guide
            </button>
        </div>
        
        <div class="file-preview flex-grow p-4">
            <div id="empty-preview" class="empty-state">
                <i class="fas fa-file-alt"></i>
                <p class="text-gray-600 font-medium">Select a file to preview</p>
                <p class="text-sm mt-2">Click on any document in the file browser to view and edit</p>
            </div>
            
            <div id="document-preview" class="hidden h-full flex flex-col">
                <div class="mb-3 flex items-center justify-between">
                    <h3 id="doc-title" class="text-lg font-medium text-gray-900"></h3>
                    <div class="flex items-center gap-2">
                        <div id="markdown-view-toggle" class="hidden">
                            <button onclick="setMarkdownView('edit')" id="md-edit-btn" class="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-l hover:bg-gray-300">
                                <i class="fas fa-edit mr-1"></i>Edit
                            </button>
                            <button onclick="setMarkdownView('preview')" id="md-preview-btn" class="px-3 py-1 text-sm bg-white text-gray-700 hover:bg-gray-100">
                                <i class="fas fa-eye mr-1"></i>Preview
                            </button>
                            <button onclick="setMarkdownView('split')" id="md-split-btn" class="px-3 py-1 text-sm bg-white text-gray-700 rounded-r hover:bg-gray-100">
                                <i class="fas fa-columns mr-1"></i>Split
                            </button>
                        </div>
                        <span id="doc-modified" class="text-sm text-gray-500"></span>
                    </div>
                </div>
                <div id="markdown-toolbar" class="markdown-toolbar hidden">
                    <button onclick="insertMarkdown('**', '**')" title="Bold (Ctrl+B)">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button onclick="insertMarkdown('*', '*')" title="Italic (Ctrl+I)">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button onclick="insertMarkdown('~~', '~~')" title="Strikethrough">
                        <i class="fas fa-strikethrough"></i>
                    </button>
                    <div class="border-l border-gray-300 h-6"></div>
                    <button onclick="insertMarkdown('# ', '')" title="Heading">
                        <i class="fas fa-heading"></i>
                    </button>
                    <button onclick="insertMarkdown('> ', '')" title="Quote">
                        <i class="fas fa-quote-left"></i>
                    </button>
                    <button onclick="insertMarkdown('```\n', '\n```')" title="Code Block">
                        <i class="fas fa-code"></i>
                    </button>
                    <button onclick="insertMarkdown('- ', '')" title="List">
                        <i class="fas fa-list"></i>
                    </button>
                    <button onclick="insertMarkdown('[', '](url)')" title="Link">
                        <i class="fas fa-link"></i>
                    </button>
                    <button onclick="insertMarkdown('![', '](url)')" title="Image">
                        <i class="fas fa-image"></i>
                    </button>
                </div>
                <div id="editor-wrapper" class="flex-grow overflow-hidden">
                    <div class="editor-container h-full">
                        <textarea id="editor" placeholder="Start typing..."></textarea>
                    </div>
                    <div id="markdown-preview-container" class="hidden h-full overflow-auto">
                        <div class="markdown-preview"></div>
                    </div>
                    <div id="split-view-container" class="hidden h-full split-editor">
                        <div class="editor-container">
                            <textarea id="split-editor" placeholder="Start typing..."></textarea>
                        </div>
                        <div class="markdown-preview overflow-auto"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <span id="status-text">Ready</span>
            <span id="cursor-position">Line 1, Column 1</span>
            <span class="shortcuts-hint" title="Ctrl+N: New Doc | Ctrl+Shift+N: New File | F2: Rename | Ctrl+S: Save | Ctrl+O: Search | Ctrl+M: Toggle Markdown View">
                <i class="fas fa-keyboard text-gray-400"></i>
            </span>
        </div>
    </div>
</div>

<!-- Context Menu -->
<div id="context-menu" class="context-menu hidden">
    <div class="context-menu-item" onclick="contextMenuAction('new-file')">
        <i class="fas fa-file-plus"></i>
        New File
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('new-folder')">
        <i class="fas fa-folder-plus"></i>
        New Folder
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextMenuAction('rename')">
        <i class="fas fa-edit"></i>
        Rename
    </div>
    <div class="context-menu-item" onclick="contextMenuAction('delete')">
        <i class="fas fa-trash"></i>
        Delete
    </div>
</div>

<!-- Search Modal -->
<div id="search-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full">
            <div class="px-6 py-4 border-b border-gray-200">
                <h3 class="text-lg font-medium text-gray-900">Search Context Hub</h3>
            </div>
            <div class="p-6">
                <div class="mb-4">
                    <input 
                        type="text" 
                        id="search-input" 
                        placeholder="Search documents..."
                        class="w-full border border-gray-300 rounded-lg px-4 py-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        onkeypress="handleSearchKeypress(event)"
                    >
                </div>
                <div id="search-results" class="max-h-96 overflow-y-auto">
                    <!-- Search results will appear here -->
                </div>
                <div class="mt-4 flex justify-end">
                    <button onclick="closeSearchModal()" class="px-4 py-2 text-gray-600 hover:text-gray-800">Close</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- New Document/Folder Modal -->
<div id="create-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-white rounded-lg shadow-xl max-w-md w-full">
            <div class="px-6 py-4 border-b border-gray-200">
                <h3 id="create-modal-title" class="text-lg font-medium text-gray-900">Create New</h3>
            </div>
            <form id="create-form" class="p-6">
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Name</label>
                    <input 
                        type="text" 
                        id="create-name" 
                        class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent" 
                        placeholder="Enter name..." 
                        required
                    >
                </div>
                <div id="create-content-field" class="mb-4 hidden">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Initial Content</label>
                    <textarea 
                        id="create-content" 
                        rows="6" 
                        class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Enter initial content (optional)..."
                    ></textarea>
                </div>
                <div class="flex justify-end space-x-3">
                    <button type="button" onclick="closeCreateModal()" class="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Create</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Upload Modal -->
<div id="upload-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden z-50">
    <div class="flex items-center justify-center min-h-screen p-4">
        <div class="bg-white rounded-lg shadow-xl max-w-md w-full">
            <div class="px-6 py-4 border-b border-gray-200">
                <h3 class="text-lg font-medium text-gray-900">Upload File</h3>
            </div>
            <form id="upload-form" class="p-6">
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Select File</label>
                    <input 
                        type="file" 
                        id="file-input" 
                        accept=".txt,.md,.json,.xml,.csv,.log,.conf,.yaml,.yml,.ini,.sh,.py,.js,.html,.css,.sql"
                        class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent" 
                        required
                    >
                    <p class="text-xs text-gray-500 mt-1">Supported: Text files (.txt, .md, .json, .xml, .csv, etc.)</p>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Upload to Folder</label>
                    <select id="upload-folder" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <option value="">Root Folder</option>
                    </select>
                </div>
                <div class="flex justify-end space-x-3">
                    <button type="button" onclick="closeUploadModal()" class="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Upload</button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // Global state
    let contextData = {
        initialized: false,
        folders: [],
        selectedItem: null,
        currentDocument: null,
        unsavedChanges: false,
        timelineMode: false,
        timelineData: null,
        currentTimelineState: null,
        timelinePosition: 0
    };
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        loadContextStatus();
        setupEventListeners();
        updateCursorPosition();
    });
    
    // Event listeners
    function setupEventListeners() {
        const editor = document.getElementById('editor');
        editor.addEventListener('input', handleEditorInput);
        editor.addEventListener('keyup', updateCursorPosition);
        editor.addEventListener('click', updateCursorPosition);
        
        // Split editor event listeners
        const splitEditor = document.getElementById('split-editor');
        splitEditor.addEventListener('input', (e) => {
            contextData.unsavedChanges = true;
            updateToolbarState();
            updateMarkdownPreview();
            // Sync to main editor
            document.getElementById('editor').value = e.target.value;
        });
        splitEditor.addEventListener('keyup', updateCursorPosition);
        splitEditor.addEventListener('click', updateCursorPosition);
        
        // Close context menu on click outside
        document.addEventListener('click', () => {
            document.getElementById('context-menu').classList.add('hidden');
        });
        
        // Deselect folders when clicking outside the file tree
        document.addEventListener('click', (e) => {
            const fileTree = document.getElementById('file-tree');
            const browserContent = document.querySelector('.browser-content');
            
            // Check if the click is outside the file tree area
            if (!fileTree.contains(e.target) && !browserContent.contains(e.target)) {
                // Deselect all selected items
                document.querySelectorAll('.tree-node.selected').forEach(n => {
                    n.classList.remove('selected');
                });
                contextData.selectedItem = null;
                updateToolbarState();
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 's') {
                    e.preventDefault();
                    saveDocument();
                } else if (e.key === 'n' && e.shiftKey) {
                    e.preventDefault();
                    createNewFile();
                } else if (e.key === 'n') {
                    e.preventDefault();
                    createNewDocument();
                } else if (e.key === 'o') {
                    e.preventDefault();
                    showSearchModal();
                } else if (e.key === 'm' && contextData.isMarkdownFile) {
                    e.preventDefault();
                    // Cycle through markdown views
                    const currentView = contextData.markdownView || 'edit';
                    const nextView = currentView === 'edit' ? 'preview' : 
                                   currentView === 'preview' ? 'split' : 'edit';
                    setMarkdownView(nextView);
                } else if (e.key === 'b' && contextData.isMarkdownFile) {
                    e.preventDefault();
                    insertMarkdown('**', '**');
                } else if (e.key === 'i' && contextData.isMarkdownFile) {
                    e.preventDefault();
                    insertMarkdown('*', '*');
                }
            } else if (e.key === 'F2' || (e.key === 'Enter' && contextData.selectedItem && !e.target.matches('input, textarea'))) {
                e.preventDefault();
                renameSelected();
            } else if (e.key === 'Delete' && contextData.selectedItem && !e.target.matches('input, textarea')) {
                e.preventDefault();
                deleteSelected();
            }
        });
    }
    
    // Load context hub status
    async function loadContextStatus() {
        try {
            const response = await fetch('/api/context/status');
            if (response.ok) {
                const data = await response.json();
                contextData.initialized = data.initialized;
                updateStatusDisplay(data);
                
                if (data.initialized) {
                    await loadFolders();
                }
            }
        } catch (error) {
            console.error('Failed to load context status:', error);
            updateStatusDisplay({ initialized: false });
        }
    }
    
    // Update status display
    function updateStatusDisplay(status) {
        const statusEl = document.getElementById('context-status');
        const initBtn = document.getElementById('init-context-btn');
        const noContextEl = document.getElementById('no-context');
        const fileTreeContainer = document.getElementById('file-tree-container');
        const fileTree = document.getElementById('file-tree');
        
        if (status.initialized) {
            statusEl.innerHTML = '<i class="fas fa-check-circle mr-1"></i> Active';
            statusEl.className = 'px-3 py-1 text-sm rounded-full bg-green-100 text-green-800';
            initBtn.classList.add('hidden');
            // Make sure no-context is hidden and file tree is visible
            noContextEl.style.display = 'none';
            fileTreeContainer.style.display = 'block';
            fileTree.style.display = 'block';
        } else {
            statusEl.innerHTML = '<i class="fas fa-exclamation-circle mr-1"></i> Not Initialized';
            statusEl.className = 'px-3 py-1 text-sm rounded-full bg-yellow-100 text-yellow-800';
            initBtn.classList.remove('hidden');
            noContextEl.style.display = 'flex';
            fileTreeContainer.style.display = 'none';
            fileTree.style.display = 'none';
        }
    }
    
    // Initialize context hub
    async function initializeContext() {
        try {
            const response = await fetch('/api/context/initialize', { method: 'POST' });
            if (response.ok) {
                showStatus('Context hub initialized successfully!', 'success');
                await loadContextStatus();
            } else {
                showStatus('Failed to initialize context hub', 'error');
            }
        } catch (error) {
            console.error('Error initializing context:', error);
            showStatus('Error initializing context hub', 'error');
        }
    }
    
    // Load folders and documents
    async function loadFolders() {
        try {
            const response = await fetch('/api/context/folders');
            if (response.ok) {
                const data = await response.json();
                contextData.folders = data.folders || [];
                
                // Debug log to see what we're getting
                console.log('Loaded folders:', contextData.folders);
                
                // Ensure all folders have their documents array
                contextData.folders.forEach(folder => {
                    if (!folder.documents) {
                        folder.documents = [];
                    }
                });
                
                renderFileTree();
                updateStats();
            }
        } catch (error) {
            console.error('Failed to load folders:', error);
            showStatus('Failed to load folders', 'error');
        }
    }
    
    // Calculate total document count for a folder including subfolders
    function calculateFolderDocumentCount(folder) {
        let count = 0;
        
        // Count documents in this folder
        if (folder.documents && Array.isArray(folder.documents)) {
            count += folder.documents.length;
        }
        
        // Count documents in subfolders recursively
        if (folder.subfolders && Array.isArray(folder.subfolders)) {
            folder.subfolders.forEach(subfolder => {
                count += calculateFolderDocumentCount(subfolder);
            });
        }
        
        return count;
    }
    
    // Find folder by ID recursively
    function findFolderById(folderId) {
        for (const folder of contextData.folders) {
            if (folder.id === folderId) {
                return folder;
            }
            // Search in subfolders
            if (folder.subfolders) {
                const found = findFolderInList(folderId, folder.subfolders);
                if (found) return found;
            }
        }
        return null;
    }
    
    // Helper to find folder in a list recursively
    function findFolderInList(folderId, folders) {
        for (const folder of folders) {
            if (folder.id === folderId) {
                return folder;
            }
            if (folder.subfolders) {
                const found = findFolderInList(folderId, folder.subfolders);
                if (found) return found;
            }
        }
        return null;
    }
    
    // Render file tree
    function renderFileTree() {
        const treeEl = document.getElementById('file-tree');
        treeEl.innerHTML = '';
        
        // Build a map for quick lookup
        const folderMap = new Map();
        contextData.folders.forEach(folder => {
            folderMap.set(folder.id, folder);
        });
        
        // Add child folders to their parents
        contextData.folders.forEach(folder => {
            if (folder.parent_id && folderMap.has(folder.parent_id)) {
                const parent = folderMap.get(folder.parent_id);
                if (!parent.subfolders) parent.subfolders = [];
                parent.subfolders.push(folder);
            }
        });
        
        // Render root level items
        const rootFolders = contextData.folders.filter(f => !f.parent_id);
        
        rootFolders.forEach(folder => {
            treeEl.appendChild(createFolderNode(folder));
        });
        
        // Add guide file at root
        const guideNode = createSpecialNode('INDEX_GUIDE.md', 'guide', 'fas fa-book');
        treeEl.appendChild(guideNode);
    }
    
    // Create folder node
    function createFolderNode(folder, level = 0) {
        const node = document.createElement('div');
        node.className = 'tree-node';
        node.dataset.type = 'folder';
        node.dataset.id = folder.id;
        node.dataset.name = folder.name;
        node.style.paddingLeft = `${(level * 20) + 8}px`; // Add base padding
        
        const isExpanded = localStorage.getItem(`folder-expanded-${folder.id}`) === 'true';
        
        // Calculate document count for this folder only (not including subfolders)
        const docCount = (folder.documents && folder.documents.length) || folder.document_count || 0;
        
        const chevronSpan = document.createElement('span');
        chevronSpan.className = 'tree-icon';
        chevronSpan.innerHTML = `<i class="fas fa-chevron-${isExpanded ? 'down' : 'right'} text-xs"></i>`;
        
        const folderIconSpan = document.createElement('span');
        folderIconSpan.className = 'tree-icon';
        folderIconSpan.innerHTML = `<i class="fas fa-folder${isExpanded ? '-open' : ''} text-blue-500"></i>`;
        
        const labelSpan = document.createElement('span');
        labelSpan.className = 'tree-label';
        labelSpan.textContent = folder.name;
        
        const countSpan = document.createElement('span');
        countSpan.className = 'text-xs text-gray-500 ml-2';
        countSpan.textContent = docCount;
        countSpan.dataset.folderId = folder.id;
        countSpan.dataset.countType = 'folder';
        
        node.appendChild(chevronSpan);
        node.appendChild(folderIconSpan);
        node.appendChild(labelSpan);
        node.appendChild(countSpan);
        
        // Add click handler to chevron for toggling
        chevronSpan.addEventListener('click', async (e) => {
            console.log('Chevron clicked for folder:', folder.id);
            e.stopPropagation();
            e.preventDefault();
            await toggleFolder(folder.id);
        });
        
        // Add click handler to rest of node for selection
        node.addEventListener('click', async (e) => {
            if (e.target !== chevronSpan && !chevronSpan.contains(e.target)) {
                e.stopPropagation();
                selectItem(node);
            }
        });
        
        node.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showContextMenu(e, node);
        });
        
        const container = document.createElement('div');
        container.appendChild(node);
        
        // Add children container
        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'tree-children';
        childrenContainer.dataset.folderId = folder.id;
        childrenContainer.style.display = isExpanded ? 'block' : 'none';
        
        // If folder is expanded, add its contents
        if (isExpanded) {
            // Add child folders
            if (folder.subfolders) {
                folder.subfolders.forEach(subfolder => {
                    childrenContainer.appendChild(createFolderNode(subfolder, level + 1));
                });
            }
            
            // Add documents
            if (folder.documents && folder.documents.length > 0) {
                folder.documents.forEach(doc => {
                    childrenContainer.appendChild(createDocumentNode({ ...doc, folder_id: folder.id }, level + 1));
                });
            }
        }
        
        container.appendChild(childrenContainer);
        
        return container;
    }
    
    // Create document node
    function createDocumentNode(doc, level = 0) {
        const node = document.createElement('div');
        node.className = 'tree-node';
        node.dataset.type = 'document';
        node.dataset.id = doc.id;
        node.dataset.name = doc.name;
        node.dataset.folderId = doc.folder_id;
        node.style.paddingLeft = `${(level * 20) + 28}px`; // Extra padding for files (20px for icon space)
        
        const icon = getFileIcon(doc.name);
        
        node.innerHTML = `
            <span class="tree-icon">
                <i class="${icon}"></i>
            </span>
            <span class="tree-label">${doc.name}</span>
        `;
        
        node.addEventListener('click', (e) => {
            e.stopPropagation();
            selectItem(node);
            loadDocument(doc.id);
        });
        
        node.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showContextMenu(e, node);
        });
        
        return node;
    }
    
    // Create special node (like guide file)
    function createSpecialNode(name, type, icon) {
        const node = document.createElement('div');
        node.className = 'tree-node';
        node.dataset.type = type;
        node.dataset.name = name;
        
        node.innerHTML = `
            <span class="tree-icon">
                <i class="${icon} text-purple-500"></i>
            </span>
            <span class="tree-label font-medium">${name}</span>
        `;
        
        node.addEventListener('click', (e) => {
            e.stopPropagation();
            selectItem(node);
            if (type === 'guide') {
                loadGuideFile();
            }
        });
        
        return node;
    }
    
    // Get file icon based on extension
    function getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const icons = {
            'md': 'fas fa-file-alt text-gray-600',
            'txt': 'fas fa-file-alt text-gray-600',
            'json': 'fas fa-file-code text-yellow-600',
            'js': 'fas fa-file-code text-yellow-600',
            'py': 'fas fa-file-code text-blue-600',
            'html': 'fas fa-file-code text-orange-600',
            'css': 'fas fa-file-code text-blue-500',
            'pdf': 'fas fa-file-pdf text-red-600',
            'doc': 'fas fa-file-word text-blue-700',
            'docx': 'fas fa-file-word text-blue-700',
            'xls': 'fas fa-file-excel text-green-700',
            'xlsx': 'fas fa-file-excel text-green-700',
        };
        return icons[ext] || 'fas fa-file text-gray-500';
    }
    
    // Toggle folder expansion
    async function toggleFolder(folderId) {
        const childrenEl = document.querySelector(`[data-folder-id="${folderId}"]`);
        const folderNode = document.querySelector(`[data-id="${folderId}"][data-type="folder"]`);
        
        if (!childrenEl || !folderNode) {
            console.error(`Could not find folder elements for id: ${folderId}`);
            console.log('Available children elements:', document.querySelectorAll('[data-folder-id]'));
            console.log('Available folder nodes:', document.querySelectorAll('[data-type="folder"]'));
            return;
        }
        
        const isExpanded = childrenEl.style.display !== 'none';
        console.log(`Folder ${folderId} is currently ${isExpanded ? 'expanded' : 'collapsed'}`);
        
        // Toggle visibility
        childrenEl.style.display = isExpanded ? 'none' : 'block';
        
        // Update icons
        const chevron = folderNode.querySelector('.fa-chevron-right, .fa-chevron-down');
        const folderIcon = folderNode.querySelector('.fa-folder, .fa-folder-open');
        
        if (chevron) {
            chevron.className = isExpanded ? 'fas fa-chevron-right text-xs' : 'fas fa-chevron-down text-xs';
        }
        if (folderIcon) {
            folderIcon.className = isExpanded ? 'fas fa-folder text-blue-500' : 'fas fa-folder-open text-blue-500';
        }
        
        // Save state
        localStorage.setItem(`folder-expanded-${folderId}`, !isExpanded);
        
        // If expanding, always render the contents (even if they exist, to refresh)
        if (!isExpanded) {
            const folder = contextData.folders.find(f => f.id === folderId);
            if (folder) {
                console.log(`Rendering contents for folder ${folder.name}:`, folder);
                
                // Clear existing content first
                childrenEl.innerHTML = '';
                
                // Calculate level from parent node's padding
                const parentPadding = parseInt(folderNode.style.paddingLeft) || 8;
                const level = Math.floor((parentPadding - 8) / 20) + 1;
                
                // Add child folders (subfolders)
                if (folder.subfolders && folder.subfolders.length > 0) {
                    console.log(`Adding ${folder.subfolders.length} subfolders`);
                    folder.subfolders.forEach(subfolder => {
                        const subfolderContainer = createFolderNode(subfolder, level);
                        if (subfolderContainer) {
                            childrenEl.appendChild(subfolderContainer);
                        }
                    });
                }
                
                // Add documents
                if (folder.documents && folder.documents.length > 0) {
                    console.log(`Adding ${folder.documents.length} documents:`, folder.documents);
                    folder.documents.forEach(doc => {
                        const docNode = createDocumentNode({ ...doc, folder_id: folderId }, level);
                        if (docNode) {
                            childrenEl.appendChild(docNode);
                            console.log(`Added document: ${doc.name}`);
                        }
                    });
                } else {
                    console.log('No documents found in folder');
                }
            }
        }
    }
    
    // Load folder contents dynamically
    async function loadFolderContents(folderId, containerEl) {
        try {
            // Find the folder in our data
            const folder = contextData.folders.find(f => f.id === folderId);
            if (!folder) return;
            
            // Calculate level from parent node's padding
            const parentNode = containerEl.parentElement.querySelector('.tree-node');
            const parentPadding = parseInt(parentNode.style.paddingLeft) || 8;
            const level = Math.floor((parentPadding - 8) / 20) + 1;
            
            // Add child folders
            if (folder.subfolders) {
                folder.subfolders.forEach(subfolder => {
                    containerEl.appendChild(createFolderNode(subfolder, level));
                });
            }
            
            // Add documents
            if (folder.documents && folder.documents.length > 0) {
                folder.documents.forEach(doc => {
                    containerEl.appendChild(createDocumentNode({ ...doc, folder_id: folderId }, level));
                });
            }
        } catch (error) {
            console.error('Error loading folder contents:', error);
        }
    }
    
    // Select item in tree
    function selectItem(node) {
        // Remove previous selection
        document.querySelectorAll('.tree-node.selected').forEach(n => {
            n.classList.remove('selected');
        });
        
        // Add selection to current node
        node.classList.add('selected');
        contextData.selectedItem = {
            type: node.dataset.type,
            id: node.dataset.id,
            name: node.dataset.name,
            folderId: node.dataset.folderId
        };
        
        // Update toolbar buttons
        updateToolbarState();
    }
    
    // Load document content
    async function loadDocument(docId) {
        try {
            const response = await fetch(`/api/context/documents/${docId}`);
            if (response.ok) {
                const doc = await response.json();
                displayDocument(doc);
                contextData.currentDocument = doc;
                contextData.unsavedChanges = false;
            } else {
                showStatus('Failed to load document', 'error');
            }
        } catch (error) {
            console.error('Error loading document:', error);
            showStatus('Error loading document', 'error');
        }
    }
    
    // Load guide file
    async function loadGuideFile() {
        try {
            const response = await fetch('/api/context/guide');
            if (response.ok) {
                const guide = await response.json();
                displayDocument({
                    id: 'guide',
                    name: 'INDEX_GUIDE.md',
                    content: guide.content || '',
                    modified_at: guide.modified_at
                });
                contextData.currentDocument = { ...guide, id: 'guide', name: 'INDEX_GUIDE.md' };
                contextData.unsavedChanges = false;
            } else {
                showStatus('Failed to load guide file', 'error');
            }
        } catch (error) {
            console.error('Error loading guide:', error);
            showStatus('Error loading guide file', 'error');
        }
    }
    
    // Display document in editor
    function displayDocument(doc) {
        document.getElementById('empty-preview').classList.add('hidden');
        document.getElementById('document-preview').classList.remove('hidden');
        
        document.getElementById('doc-title').textContent = doc.name;
        document.getElementById('doc-modified').textContent = doc.modified_at ? 
            `Modified: ${new Date(doc.modified_at).toLocaleString()}` : '';
        
        const editor = document.getElementById('editor');
        const splitEditor = document.getElementById('split-editor');
        editor.value = doc.content || '';
        splitEditor.value = doc.content || '';
        editor.focus();
        
        // Check if it's a markdown file
        const isMarkdown = doc.name.toLowerCase().endsWith('.md') || doc.name.toLowerCase().endsWith('.markdown');
        contextData.isMarkdownFile = isMarkdown;
        
        const toggleDiv = document.getElementById('markdown-view-toggle');
        const toolbar = document.getElementById('markdown-toolbar');
        if (isMarkdown) {
            toggleDiv.classList.remove('hidden');
            toolbar.classList.remove('hidden');
            // Default to edit view
            setMarkdownView('edit');
        } else {
            toggleDiv.classList.add('hidden');
            toolbar.classList.add('hidden');
            setMarkdownView('edit'); // Force edit view for non-markdown files
        }
        
        updateCursorPosition();
    }
    
    // Handle editor input
    function handleEditorInput(e) {
        contextData.unsavedChanges = true;
        updateToolbarState();
        
        // Update markdown preview if in preview or split mode
        if (contextData.isMarkdownFile && contextData.markdownView !== 'edit') {
            updateMarkdownPreview();
        }
    }
    
    // Set markdown view mode
    function setMarkdownView(mode) {
        contextData.markdownView = mode;
        
        const editorContainer = document.querySelector('.editor-container');
        const previewContainer = document.getElementById('markdown-preview-container');
        const splitContainer = document.getElementById('split-view-container');
        const editBtn = document.getElementById('md-edit-btn');
        const previewBtn = document.getElementById('md-preview-btn');
        const splitBtn = document.getElementById('md-split-btn');
        const toolbar = document.getElementById('markdown-toolbar');
        
        // Hide all containers first
        editorContainer.parentElement.classList.add('hidden');
        previewContainer.classList.add('hidden');
        splitContainer.classList.add('hidden');
        
        // Reset button states
        [editBtn, previewBtn, splitBtn].forEach(btn => {
            btn.classList.remove('bg-gray-200');
            btn.classList.add('bg-white');
        });
        
        // Show appropriate container and update button state
        switch (mode) {
            case 'edit':
                editorContainer.parentElement.classList.remove('hidden');
                editBtn.classList.remove('bg-white');
                editBtn.classList.add('bg-gray-200');
                toolbar.classList.remove('hidden');
                break;
            case 'preview':
                previewContainer.classList.remove('hidden');
                previewBtn.classList.remove('bg-white');
                previewBtn.classList.add('bg-gray-200');
                toolbar.classList.add('hidden');
                updateMarkdownPreview();
                break;
            case 'split':
                splitContainer.classList.remove('hidden');
                splitBtn.classList.remove('bg-white');
                splitBtn.classList.add('bg-gray-200');
                toolbar.classList.remove('hidden');
                updateMarkdownPreview();
                // Sync content from main editor to split editor
                document.getElementById('split-editor').value = document.getElementById('editor').value;
                break;
        }
    }
    
    // Update markdown preview
    function updateMarkdownPreview() {
        const content = contextData.markdownView === 'split' ? 
            document.getElementById('split-editor').value : 
            document.getElementById('editor').value;
        
        const previewElement = contextData.markdownView === 'split' ?
            document.querySelector('#split-view-container .markdown-preview') :
            document.querySelector('#markdown-preview-container .markdown-preview');
        
        if (previewElement && window.marked) {
            // Configure marked options
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: true,
                mangle: false,
                sanitize: false
            });
            
            // Render markdown
            previewElement.innerHTML = marked.parse(content || '');
            
            // Add syntax highlighting if code blocks are present
            previewElement.querySelectorAll('pre code').forEach(block => {
                block.classList.add('hljs');
            });
        }
    }
    
    // Insert markdown formatting
    function insertMarkdown(prefix, suffix) {
        const editor = contextData.markdownView === 'split' ? 
            document.getElementById('split-editor') : 
            document.getElementById('editor');
        
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const text = editor.value;
        const selectedText = text.substring(start, end);
        
        // Insert the markdown
        const newText = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
        editor.value = newText;
        
        // Update cursor position
        const newCursorPos = start + prefix.length + selectedText.length;
        editor.setSelectionRange(newCursorPos, newCursorPos);
        editor.focus();
        
        // Trigger input event to update preview and mark as unsaved
        editor.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    // Save document
    async function saveDocument() {
        if (!contextData.currentDocument || !contextData.unsavedChanges) return;
        
        // Get content from the active editor
        const content = contextData.markdownView === 'split' ? 
            document.getElementById('split-editor').value : 
            document.getElementById('editor').value;
        
        try {
            let response;
            if (contextData.currentDocument.id === 'guide') {
                // Save guide file
                response = await fetch('/api/context/guide', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content })
                });
            } else {
                // Save regular document
                response = await fetch(`/api/context/documents/${contextData.currentDocument.id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name: contextData.currentDocument.name,
                        content 
                    })
                });
            }
            
            if (response.ok) {
                contextData.unsavedChanges = false;
                updateToolbarState();
                showStatus('Document saved successfully', 'success');
            } else {
                showStatus('Failed to save document', 'error');
            }
        } catch (error) {
            console.error('Error saving document:', error);
            showStatus('Error saving document', 'error');
        }
    }
    
    // Delete selected item
    async function deleteSelected() {
        if (!contextData.selectedItem) return;
        
        const confirmMsg = contextData.selectedItem.type === 'folder' ?
            'Delete this folder and all its contents?' :
            'Delete this document?';
            
        if (!confirm(confirmMsg)) return;
        
        try {
            const endpoint = contextData.selectedItem.type === 'folder' ?
                `/api/context/folders/${contextData.selectedItem.id}` :
                `/api/context/documents/${contextData.selectedItem.id}`;
                
            const response = await fetch(endpoint, { method: 'DELETE' });
            
            if (response.ok) {
                showStatus('Deleted successfully', 'success');
                await loadFolders();
                
                // Clear editor if deleted document was open
                if (contextData.currentDocument?.id === contextData.selectedItem.id) {
                    document.getElementById('empty-preview').classList.remove('hidden');
                    document.getElementById('document-preview').classList.add('hidden');
                    contextData.currentDocument = null;
                }
            } else {
                showStatus('Failed to delete', 'error');
            }
        } catch (error) {
            console.error('Error deleting:', error);
            showStatus('Error deleting item', 'error');
        }
    }
    
    // Rename selected item
    async function renameSelected() {
        if (!contextData.selectedItem) return;
        
        const newName = prompt('Enter new name:', contextData.selectedItem.name);
        if (!newName || newName === contextData.selectedItem.name) return;
        
        try {
            const endpoint = contextData.selectedItem.type === 'folder' ?
                `/api/context/folders/${contextData.selectedItem.id}` :
                `/api/context/documents/${contextData.selectedItem.id}`;
                
            const response = await fetch(endpoint, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            });
            
            if (response.ok) {
                showStatus('Renamed successfully', 'success');
                await loadFolders();
                
                // Update document title if it's open
                if (contextData.currentDocument?.id === contextData.selectedItem.id) {
                    contextData.currentDocument.name = newName;
                    document.getElementById('doc-title').textContent = newName;
                }
            } else {
                showStatus('Failed to rename', 'error');
            }
        } catch (error) {
            console.error('Error renaming:', error);
            showStatus('Error renaming item', 'error');
        }
    }
    
    // Create new folder
    function createNewFolder() {
        contextData.createType = 'folder';
        let title = 'Create New Folder';
        
        // Show parent folder in title if one is selected
        if (contextData.selectedItem && contextData.selectedItem.type === 'folder') {
            title += ` in "${contextData.selectedItem.name}"`;
        } else {
            title += ' (Root Level)';
        }
        
        document.getElementById('create-modal-title').textContent = title;
        document.getElementById('create-content-field').classList.add('hidden');
        document.getElementById('create-modal').classList.remove('hidden');
        document.getElementById('create-name').focus();
    }
    
    // Create new document
    function createNewDocument() {
        contextData.createType = 'document';
        let title = 'Create New Document';
        
        // Show folder in title if one is selected
        if (contextData.selectedItem && contextData.selectedItem.type === 'folder') {
            title += ` in "${contextData.selectedItem.name}"`;
        } else if (contextData.selectedItem && contextData.selectedItem.folderId) {
            // If a document is selected, find its parent folder name
            const parentFolder = contextData.folders.find(f => f.id === contextData.selectedItem.folderId);
            if (parentFolder) {
                title += ` in "${parentFolder.name}"`;
            }
        } else {
            title += ' (Root Level)';
        }
        
        document.getElementById('create-modal-title').textContent = title;
        document.getElementById('create-content-field').classList.remove('hidden');
        document.getElementById('create-modal').classList.remove('hidden');
        document.getElementById('create-name').focus();
    }
    
    // Create new file (empty document)
    function createNewFile() {
        contextData.createType = 'file';
        let title = 'Create New File';
        
        // Show folder in title if one is selected
        if (contextData.selectedItem && contextData.selectedItem.type === 'folder') {
            title += ` in "${contextData.selectedItem.name}"`;
        } else if (contextData.selectedItem && contextData.selectedItem.folderId) {
            // If a document is selected, find its parent folder name
            const parentFolder = contextData.folders.find(f => f.id === contextData.selectedItem.folderId);
            if (parentFolder) {
                title += ` in "${parentFolder.name}"`;
            }
        } else {
            title += ' (Root Level)';
        }
        
        document.getElementById('create-modal-title').textContent = title;
        document.getElementById('create-content-field').classList.add('hidden'); // Hide content field for new files
        document.getElementById('create-modal').classList.remove('hidden');
        document.getElementById('create-name').value = 'untitled.txt'; // Default name
        document.getElementById('create-name').focus();
        document.getElementById('create-name').select(); // Select the text for easy editing
    }
    
    // Handle create form submission
    document.getElementById('create-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const name = document.getElementById('create-name').value;
        const content = document.getElementById('create-content').value;
        
        try {
            let response;
            if (contextData.createType === 'folder') {
                response = await fetch('/api/context/folders', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        parent_id: contextData.selectedItem?.type === 'folder' ? contextData.selectedItem.id : null
                    })
                });
            } else {
                // For both 'document' and 'file' types, create a document
                const documentContent = contextData.createType === 'file' ? '' : content;
                response = await fetch('/api/context/documents', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        content: documentContent,
                        folder_id: contextData.selectedItem?.type === 'folder' ? contextData.selectedItem.id : contextData.selectedItem?.folderId
                    })
                });
            }
            
            if (response.ok) {
                const responseData = await response.json();
                closeCreateModal();
                
                // For documents/files, update the parent folder's document list
                if (contextData.createType !== 'folder' && responseData) {
                    const parentFolderId = contextData.selectedItem?.type === 'folder' ? 
                        contextData.selectedItem.id : contextData.selectedItem?.folderId;
                    
                    if (parentFolderId) {
                        // Find the parent folder and add the new document
                        const parentFolder = findFolderById(parentFolderId);
                        if (parentFolder && !parentFolder.documents.find(d => d.id === responseData.id)) {
                            parentFolder.documents.push({
                                id: responseData.id,
                                name: responseData.name,
                                content: responseData.content || '',
                                folder_id: parentFolderId,
                                created_at: responseData.created_at,
                                modified_at: responseData.modified_at
                            });
                        }
                    }
                }
                
                // If we created a document in a folder, ensure that folder is expanded
                const targetFolderId = contextData.selectedItem?.type === 'folder' ? 
                    contextData.selectedItem.id : contextData.selectedItem?.folderId;
                if (targetFolderId && contextData.createType !== 'folder') {
                    localStorage.setItem(`folder-expanded-${targetFolderId}`, 'true');
                }
                
                // Reload folders to get fresh data
                await loadFolders();
                const itemType = contextData.createType === 'folder' ? 'Folder' : contextData.createType === 'file' ? 'File' : 'Document';
                showStatus(`${itemType} created successfully`, 'success');
                
                // If it's a new file or document, automatically open it for editing
                if ((contextData.createType === 'file' || contextData.createType === 'document') && responseData && responseData.id) {
                    // Small delay to let the UI update
                    setTimeout(() => loadDocument(responseData.id), 100);
                }
            } else {
                showStatus('Failed to create', 'error');
            }
        } catch (error) {
            console.error('Error creating:', error);
            showStatus('Error creating item', 'error');
        }
    });
    
    // Close create modal
    function closeCreateModal() {
        document.getElementById('create-modal').classList.add('hidden');
        document.getElementById('create-form').reset();
    }
    
    // Show context menu
    function showContextMenu(e, node) {
        const menu = document.getElementById('context-menu');
        menu.style.left = `${e.pageX}px`;
        menu.style.top = `${e.pageY}px`;
        menu.classList.remove('hidden');
        
        contextData.contextMenuTarget = {
            type: node.dataset.type,
            id: node.dataset.id,
            name: node.dataset.name
        };
    }
    
    // Handle context menu actions
    function contextMenuAction(action) {
        document.getElementById('context-menu').classList.add('hidden');
        
        switch (action) {
            case 'new-file':
                createNewDocument();
                break;
            case 'new-folder':
                createNewFolder();
                break;
            case 'rename':
                if (contextData.contextMenuTarget) {
                    contextData.selectedItem = contextData.contextMenuTarget;
                    renameSelected();
                }
                break;
            case 'delete':
                if (contextData.contextMenuTarget) {
                    contextData.selectedItem = contextData.contextMenuTarget;
                    deleteSelected();
                }
                break;
        }
    }
    
    // Search functionality
    function showSearchModal() {
        document.getElementById('search-modal').classList.remove('hidden');
        document.getElementById('search-input').focus();
    }
    
    function closeSearchModal() {
        document.getElementById('search-modal').classList.add('hidden');
        document.getElementById('search-input').value = '';
        document.getElementById('search-results').innerHTML = '';
    }
    
    async function handleSearchKeypress(e) {
        if (e.key === 'Enter') {
            const query = e.target.value.trim();
            if (!query) return;
            
            try {
                const response = await fetch(`/api/context/search?q=${encodeURIComponent(query)}&limit=20`);
                if (response.ok) {
                    const data = await response.json();
                    displaySearchResults(data.results || []);
                }
            } catch (error) {
                console.error('Search error:', error);
            }
        }
    }
    
    function displaySearchResults(results) {
        const container = document.getElementById('search-results');
        container.innerHTML = '';
        
        if (results.length === 0) {
            container.innerHTML = '<p class="text-gray-500 text-center py-4">No results found</p>';
            return;
        }
        
        results.forEach(result => {
            const item = document.createElement('div');
            item.className = 'border border-gray-200 rounded-lg p-3 mb-2 cursor-pointer hover:bg-gray-50';
            item.innerHTML = `
                <div class="font-medium text-gray-900">${result.name}</div>
                <div class="text-sm text-gray-600 mt-1">${result.content ? result.content.substring(0, 150) + '...' : ''}</div>
            `;
            item.addEventListener('click', () => {
                closeSearchModal();
                loadDocument(result.id);
            });
            container.appendChild(item);
        });
    }
    
    // Update cursor position
    function updateCursorPosition() {
        const editor = document.getElementById('editor');
        const lines = editor.value.substr(0, editor.selectionStart).split('\n');
        const line = lines.length;
        const col = lines[lines.length - 1].length + 1;
        document.getElementById('cursor-position').textContent = `Line ${line}, Column ${col}`;
    }
    
    // Update toolbar state
    function updateToolbarState() {
        const saveBtn = document.getElementById('save-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const renameBtn = document.getElementById('rename-btn');
        const downloadBtn = document.getElementById('download-btn');
        
        saveBtn.disabled = !contextData.unsavedChanges || !contextData.currentDocument;
        deleteBtn.disabled = !contextData.selectedItem || contextData.selectedItem.type === 'guide';
        renameBtn.disabled = !contextData.selectedItem || contextData.selectedItem.type === 'guide';
        downloadBtn.disabled = !contextData.selectedItem || contextData.selectedItem.type === 'folder' || contextData.selectedItem.type === 'guide';
    }
    
    // Update statistics
    function updateStats() {
        let docCount = 0;
        let folderCount = contextData.folders.length;
        
        // Count all documents in all folders
        contextData.folders.forEach(folder => {
            if (folder.documents && Array.isArray(folder.documents)) {
                docCount += folder.documents.length;
            }
            // Also use document_count if available and higher
            if (folder.document_count && folder.document_count > 0) {
                const folderDocCount = folder.documents ? folder.documents.length : 0;
                docCount += Math.max(0, folder.document_count - folderDocCount);
            }
        });
        
        document.getElementById('doc-count').textContent = docCount;
        document.getElementById('folder-count').textContent = folderCount;
    }
    
    // Show status message
    function showStatus(message, type = 'info') {
        const statusEl = document.getElementById('status-text');
        statusEl.textContent = message;
        
        if (type === 'error') {
            statusEl.style.color = '#dc2626';
        } else if (type === 'success') {
            statusEl.style.color = '#059669';
        } else {
            statusEl.style.color = '#6b7280';
        }
        
        setTimeout(() => {
            statusEl.textContent = 'Ready';
            statusEl.style.color = '#6b7280';
        }, 3000);
    }
    
    // Refresh all data
    async function refreshAll() {
        showStatus('Refreshing...', 'info');
        await loadContextStatus();
        showStatus('Refreshed', 'success');
    }
    
    // Edit guide file
    function editGuideFile() {
        const guideNode = document.querySelector('[data-type="guide"]');
        if (guideNode) {
            selectItem(guideNode);
            loadGuideFile();
        }
    }
    
    // Upload functions
    function uploadFile() {
        document.getElementById('upload-modal').classList.remove('hidden');
        populateUploadFolderSelect();
    }
    
    function closeUploadModal() {
        document.getElementById('upload-modal').classList.add('hidden');
        document.getElementById('upload-form').reset();
    }
    
    function populateUploadFolderSelect() {
        const select = document.getElementById('upload-folder');
        select.innerHTML = '<option value="">Root Folder</option>';
        
        if (contextData.folders) {
            contextData.folders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = folder.name;
                select.appendChild(option);
            });
        }
        
        // Pre-select current folder if one is selected
        if (contextData.selectedItem && contextData.selectedItem.type === 'folder') {
            select.value = contextData.selectedItem.id;
        }
    }
    
    // Handle file upload
    document.getElementById('upload-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const fileInput = document.getElementById('file-input');
        const file = fileInput.files[0];
        const folderId = document.getElementById('upload-folder').value || null;
        
        if (!file) {
            showStatus('Please select a file', 'error');
            return;
        }
        
        try {
            showStatus('Reading file...', 'info');
            const content = await readFileContent(file);
            
            // Create document with file content
            const response = await fetch('/api/context/documents', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: file.name,
                    content: content,
                    folder_id: folderId
                })
            });
            
            if (response.ok) {
                closeUploadModal();
                await loadFolders();
                showStatus(`File "${file.name}" uploaded successfully`, 'success');
            } else {
                showStatus('Failed to upload file', 'error');
            }
        } catch (error) {
            console.error('Upload error:', error);
            showStatus('Error uploading file', 'error');
        }
    });
    
    // Read file content as text
    function readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = reject;
            reader.readAsText(file);
        });
    }
    
    // Download selected document
    async function downloadSelected() {
        if (!contextData.selectedItem || contextData.selectedItem.type === 'folder') return;
        
        try {
            showStatus('Downloading...', 'info');
            const response = await fetch(`/api/context/documents/${contextData.selectedItem.id}`);
            
            if (response.ok) {
                const doc = await response.json();
                downloadFile(doc.name, doc.content);
                showStatus('Download complete', 'success');
            } else {
                showStatus('Failed to download document', 'error');
            }
        } catch (error) {
            console.error('Download error:', error);
            showStatus('Error downloading document', 'error');
        }
    }
    
    // Download file to user's computer
    function downloadFile(filename, content) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }
    
    // Modal click handlers
    document.getElementById('search-modal').addEventListener('click', (e) => {
        if (e.target.id === 'search-modal') {
            closeSearchModal();
        }
    });
    
    document.getElementById('create-modal').addEventListener('click', (e) => {
        if (e.target.id === 'create-modal') {
            closeCreateModal();
        }
    });
    
    document.getElementById('upload-modal').addEventListener('click', (e) => {
        if (e.target.id === 'upload-modal') {
            closeUploadModal();
        }
    });

    // Timeline Functions
    async function toggleTimelineMode() {
        contextData.timelineMode = !contextData.timelineMode;
        const timelineContainer = document.getElementById('timeline-container');
        const toggleBtn = document.getElementById('timeline-toggle');
        const contentPanel = document.querySelector('.content-panel');
        const timelineBanner = document.getElementById('timeline-banner');

        if (contextData.timelineMode) {
            // Enter timeline mode
            toggleBtn.innerHTML = '<i class="fas fa-times mr-2"></i>Exit Timeline';
            toggleBtn.className = 'bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors';
            timelineContainer.classList.remove('hidden');
            timelineBanner.classList.remove('hidden');
            contentPanel.classList.add('timeline-readonly');
            
            // Load timeline data
            await loadTimelineData();
            showStatus('Timeline mode active - Read-only view', 'info');
        } else {
            exitTimelineMode();
        }
    }
    
    async function exitTimelineMode() {
        contextData.timelineMode = false;
        const timelineContainer = document.getElementById('timeline-container');
        const toggleBtn = document.getElementById('timeline-toggle');
        const contentPanel = document.querySelector('.content-panel');
        const timelineBanner = document.getElementById('timeline-banner');
        
        // Exit timeline mode
        toggleBtn.innerHTML = '<i class="fas fa-history mr-2"></i>Timeline';
        toggleBtn.className = 'bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition-colors';
        timelineContainer.classList.add('hidden');
        timelineBanner.classList.add('hidden');
        contentPanel.classList.remove('timeline-readonly');
        
        // Return to current state
        contextData.timelineData = null;
        contextData.currentTimelineState = null;
        await loadContextStatus();
        showStatus('Returned to current view', 'success');
    }

    async function loadTimelineData() {
        try {
            showStatus('Loading timeline data...', 'info');
            const response = await fetch('/api/context/timeline/snapshots');
            if (response.ok) {
                const data = await response.json();
                contextData.timelineData = data;
                renderTimelineHeatmap(data.snapshots);
                renderTimelineFlags(data.change_events);
                showStatus('Timeline loaded', 'success');
            } else {
                showStatus('Failed to load timeline data', 'error');
            }
        } catch (error) {
            console.error('Timeline load error:', error);
            showStatus('Error loading timeline', 'error');
        }
    }

    function renderTimelineHeatmap(snapshots) {
        const heatmapContainer = document.getElementById('timeline-heatmap');
        heatmapContainer.innerHTML = '';
        
        if (!snapshots || snapshots.length === 0) {
            heatmapContainer.innerHTML = '<div class="text-center text-gray-500 py-4">No timeline data available</div>';
            return;
        }

        // Create activity heatmap
        snapshots.forEach((snapshot, index) => {
            const segment = document.createElement('div');
            segment.className = `timeline-segment ${getActivityLevel(snapshot.activity_score)}`;
            segment.style.width = `${100 / snapshots.length}%`;
            segment.dataset.index = index;
            segment.dataset.timestamp = snapshot.timestamp;
            segment.title = `${new Date(snapshot.timestamp).toLocaleString()} - Activity: ${snapshot.activity_score}`;
            
            segment.addEventListener('click', () => {
                scrubToPosition(index);
            });
            
            heatmapContainer.appendChild(segment);
        });
    }

    function renderTimelineFlags(changeEvents) {
        const flagsContainer = document.getElementById('timeline-flags');
        flagsContainer.innerHTML = '';
        
        if (!changeEvents || changeEvents.length === 0) return;

        changeEvents.forEach(event => {
            const flag = document.createElement('div');
            flag.className = `timeline-flag ${event.change_type}`;
            flag.style.left = `${event.relative_position * 100}%`;
            flag.innerHTML = `<div class="flag-indicator"></div>`;
            flag.title = `${event.change_type} change: ${event.description}`;
            
            flag.addEventListener('click', () => {
                scrubToPosition(event.snapshot_index);
            });
            
            flagsContainer.appendChild(flag);
        });
    }

    function getActivityLevel(score) {
        if (score >= 0.7) return 'high-activity';
        if (score >= 0.3) return 'medium-activity';
        return 'low-activity';
    }

    async function scrubToPosition(index) {
        if (!contextData.timelineData || !contextData.timelineData.snapshots[index]) return;
        
        contextData.timelinePosition = index;
        const snapshot = contextData.timelineData.snapshots[index];
        
        try {
            // Load historical state
            const response = await fetch(`/api/context/timeline/state/${snapshot.id}`);
            if (response.ok) {
                const historicalState = await response.json();
                contextData.currentTimelineState = historicalState;
                
                // Update UI to show historical state
                renderHistoricalState(historicalState);
                updateTimelinePosition(index);
                
                // Update timestamp display
                document.getElementById('timeline-timestamp').textContent = 
                    new Date(snapshot.timestamp).toLocaleString();
                
                showStatus(`Viewing state from ${new Date(snapshot.timestamp).toLocaleString()}`, 'info');
            }
        } catch (error) {
            console.error('Error loading historical state:', error);
            showStatus('Error loading historical state', 'error');
        }
    }

    function renderHistoricalState(state) {
        // Update file tree with historical data
        contextData.folders = state.folders || [];
        renderFileTree();
        
        // If a document was selected, load its historical content
        if (contextData.selectedItem && contextData.selectedItem.type === 'document') {
            const historicalDoc = findHistoricalDocument(contextData.selectedItem.dataset.id, state);
            if (historicalDoc) {
                displayHistoricalDocument(historicalDoc);
            }
        }
    }

    function findHistoricalDocument(docId, state) {
        for (const folder of state.folders) {
            if (folder.documents) {
                const doc = folder.documents.find(d => d.id === docId);
                if (doc) return doc;
            }
        }
        return null;
    }

    function displayHistoricalDocument(doc) {
        const editor = document.getElementById('editor');
        const docTitle = document.getElementById('doc-title');
        
        editor.value = doc.content || '';
        editor.disabled = true; // Read-only in timeline mode
        docTitle.textContent = `${doc.name} (Historical)`;
        
        document.getElementById('document-preview').classList.remove('hidden');
        document.getElementById('empty-preview').classList.add('hidden');
    }

    function updateTimelinePosition(index) {
        // Update scrubber position
        const scrubber = document.getElementById('timeline-scrubber');
        const percentage = (index / (contextData.timelineData.snapshots.length - 1)) * 100;
        scrubber.style.left = `${percentage}%`;
        
        // Update active segment
        document.querySelectorAll('.timeline-segment').forEach((segment, i) => {
            segment.classList.toggle('active', i === index);
        });
    }

    function showRestoreModal() {
        if (!contextData.currentTimelineState || !contextData.selectedItem) {
            showStatus('No item selected for restoration', 'error');
            return;
        }
        
        const modal = document.getElementById('restore-modal');
        const timestamp = document.getElementById('restore-timestamp');
        const details = document.getElementById('restore-details');
        
        const snapshot = contextData.timelineData.snapshots[contextData.timelinePosition];
        timestamp.textContent = new Date(snapshot.timestamp).toLocaleString();
        details.textContent = `Selected: ${contextData.selectedItem.dataset.name}`;
        
        modal.classList.remove('hidden');
    }

    function closeRestoreModal() {
        document.getElementById('restore-modal').classList.add('hidden');
        document.getElementById('restore-overwrite').checked = false;
    }

    async function executeRestore() {
        if (!contextData.currentTimelineState || !contextData.selectedItem) {
            showStatus('Nothing to restore', 'error');
            return;
        }
        
        const overwrite = document.getElementById('restore-overwrite').checked;
        const itemId = contextData.selectedItem.dataset.id;
        const itemType = contextData.selectedItem.dataset.type;
        
        try {
            const response = await fetch('/api/context/timeline/restore', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    item_id: itemId,
                    item_type: itemType,
                    snapshot_id: contextData.timelineData.snapshots[contextData.timelinePosition].id,
                    overwrite: overwrite
                })
            });
            
            if (response.ok) {
                closeRestoreModal();
                showStatus('Item restored successfully', 'success');
                // Note: In real implementation, you might want to refresh current state
            } else {
                showStatus('Failed to restore item', 'error');
            }
        } catch (error) {
            console.error('Restore error:', error);
            showStatus('Error during restoration', 'error');
        }
    }

    // Timeline drag functionality for scrubber
    let isDragging = false;
    
    document.getElementById('timeline-track').addEventListener('mousedown', (e) => {
        if (!contextData.timelineMode || !contextData.timelineData) return;
        
        isDragging = true;
        handleTimelineDrag(e);
        
        document.addEventListener('mousemove', handleTimelineDrag);
        document.addEventListener('mouseup', () => {
            isDragging = false;
            document.removeEventListener('mousemove', handleTimelineDrag);
        });
    });
    
    function handleTimelineDrag(e) {
        if (!isDragging || !contextData.timelineData) return;
        
        const track = document.getElementById('timeline-track');
        const rect = track.getBoundingClientRect();
        const percentage = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        const index = Math.round(percentage * (contextData.timelineData.snapshots.length - 1));
        
        scrubToPosition(index);
    }
</script>
{% endblock %}